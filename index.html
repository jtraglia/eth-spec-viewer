<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Ethereum Consensus Specifications</title>
  <style>
    :root {
      --bg-color: #ffffff;
      --text-color: #000000;
      --header-bg: #ddd;
      --card-bg: #fafafa;
      --card-border: #999;
      --details-bg: #eee;
      --details-border: #ccc;
      --expanded-bg: #f9f9f9;
      --table-header-bg: #ddd;
      --table-border: #bbb;
      --search-bg: #f1f1f1;
      --search-border: #ccc;
      --toggle-bg: #f0f0f0;
      --toggle-border: #ccc;
      --button-bg: #f0f0f0;
      --button-hover: #e0e0e0;
      --button-active: #d0d0d0;
      --filter-bg: #f5f5f5;
      --deprecated-bg: #ffe6e6;
    }

    [data-theme="dark"] {
      --bg-color: #1e1e1e;
      --text-color: #e0e0e0;
      --header-bg: #333;
      --card-bg: #2a2a2a;
      --card-border: #444;
      --details-bg: #333;
      --details-border: #555;
      --expanded-bg: #252525;
      --table-header-bg: #333;
      --table-border: #555;
      --search-bg: #333;
      --search-border: #555;
      --toggle-bg: #333;
      --toggle-border: #555;
      --button-bg: #404040;
      --button-hover: #505050;
      --button-active: #606060;
      --filter-bg: #2d2d2d;
      --deprecated-bg: #402020;
    }

    body {
      font-family: Arial, sans-serif;
      max-width: 100%;
      margin: 0;
      padding: 20px;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    .header-container {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .controls-container {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
      margin: 15px 0;
    }

    .search-container {
      display: flex;
      flex: 1;
      max-width: 500px;
      position: relative;
      margin-bottom: 10px;
    }

    #searchInput {
      width: 100%;
      padding: 10px 15px;
      border: 1px solid var(--search-border);
      border-radius: 4px;
      font-size: 16px;
      background-color: var(--search-bg);
      color: var(--text-color);
    }

    #searchClear {
      position: absolute;
      right: 10px;
      top: 50%;
      transform: translateY(-50%);
      cursor: pointer;
      background: none;
      border: none;
      color: var(--text-color);
      font-size: 16px;
    }

    .toggle-container {
      display: flex;
      align-items: center;
      margin-right: 10px;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
      margin: 0 10px;
    }

    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }

    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--toggle-bg);
      border: 1px solid var(--toggle-border);
      border-radius: 24px;
      transition: .4s;
    }

    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 18px;
      width: 18px;
      left: 3px;
      bottom: 2px;
      background-color: var(--text-color);
      border-radius: 50%;
      transition: .4s;
    }

    input:checked + .toggle-slider:before {
      transform: translateX(26px);
    }

    .phase-group {
      border: 2px solid var(--card-border);
      border-radius: 5px;
      margin-bottom: 20px;
      padding: 10px;
      background: var(--card-bg);
    }
    .phase-group h2 {
      margin-top: 0;
      margin-bottom: 10px;
      background: var(--header-bg);
      padding: 8px;
      border-radius: 4px;
    }

    .preset-group {
      margin-bottom: 10px;
      border: 1px solid var(--details-border);
      border-radius: 4px;
      overflow: hidden;
    }
    details {
      margin: 0;
      padding: 0;
    }
    summary {
      cursor: pointer;
      list-style: none;
      padding: 10px;
      background: var(--details-bg);
      font-weight: bold;
      border-bottom: 1px solid var(--details-border);
      outline: none; /* remove outline on click */
    }
    summary::-webkit-details-marker {
      /* Hide default arrow in Chrome/Safari */
      display: none;
    }
    .summary-icon::before {
      content: "▶ ";
    }
    details[open] .summary-icon::before {
      content: "▼ ";
    }
    .collapsed-header {
      display: inline-block;
      vertical-align: middle;
      margin-left: 5px;
    }
    .expanded-content {
      padding: 10px;
      background: var(--expanded-bg);
    }

    .badge {
      display: inline-block;
      color: #fff;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 0.85em;
      margin-left: 8px;
      vertical-align: middle;
    }

    .deprecated-badge {
      display: inline-block;
      background-color: #dc3545;
      color: #fff;
      border-radius: 3px;
      padding: 2px 6px;
      font-size: 0.85em;
      margin-left: 8px;
      vertical-align: middle;
    }

    .deprecated-item {
      position: relative;
      background-color: var(--deprecated-bg);
    }

    .fork-table {
      width: 100%;
      max-width: 800px;
      border-collapse: collapse;
      margin-top: 10px;
      border: 1px solid var(--table-border);
    }
    .fork-table th,
    .fork-table td {
      border: 1px solid var(--table-border);
      padding: 5px;
      text-align: left;
    }
    .fork-table th {
      background: var(--table-header-bg);
    }

    .filter-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 15px;
    }

    .filter-select {
      padding: 8px 12px;
      border-radius: 4px;
      border: 1px solid var(--search-border);
      background-color: var(--search-bg);
      color: var(--text-color);
    }

    .filter-button {
      padding: 8px 15px;
      border-radius: 4px;
      border: 1px solid var(--button-bg);
      background-color: var(--button-bg);
      cursor: pointer;
      color: var(--text-color);
    }

    .filter-button:hover {
      background-color: var(--button-hover);
    }

    .filter-button:active {
      background-color: var(--button-active);
    }

    .filter-badge {
      display: inline-flex;
      align-items: center;
      background-color: var(--filter-bg);
      border-radius: 20px;
      padding: 5px 12px;
      margin: 5px;
      font-size: 0.9em;
    }

    .filter-badge-remove {
      cursor: pointer;
      margin-left: 8px;
      font-weight: bold;
    }

    .hidden {
      display: none !important;
    }

    .share-button {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 18px;
      color: var(--text-color);
      margin-left: 5px;
      vertical-align: middle;
    }

    .show-diff-checkbox {
      margin-left: 8px;
    }

    .diff-highlight-added {
      background-color: rgba(0, 255, 0, 0.2);
    }

    .diff-highlight-removed {
      background-color: rgba(255, 0, 0, 0.2);
      text-decoration: line-through;
    }

    [data-theme="dark"] .diff-highlight-added {
      background-color: rgba(0, 100, 0, 0.4);
    }

    [data-theme="dark"] .diff-highlight-removed {
      background-color: rgba(100, 0, 0, 0.4);
    }

    .no-results {
      padding: 20px;
      text-align: center;
      font-style: italic;
      color: var(--text-color);
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
      .header-container {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .controls-container {
        flex-direction: column;
        align-items: flex-start;
      }
      
      .search-container {
        max-width: 100%;
      }
    }
  </style>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/toolbar/prism-toolbar.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
  
  <!-- Font Awesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
  <div class="header-container">
    <h1>Ethereum Consensus Specifications</h1>
    
    <div class="toggle-container">
      <i class="fas fa-sun"></i>
      <label class="toggle-switch">
        <input type="checkbox" id="darkModeToggle">
        <span class="toggle-slider"></span>
      </label>
      <i class="fas fa-moon"></i>
    </div>
  </div>

  <div class="controls-container">
    <div class="search-container">
      <input type="text" id="searchInput" placeholder="Search specifications...">
      <button id="searchClear" class="hidden">&times;</button>
    </div>
    
    <div class="filter-container">
      <select id="forkFilter" class="filter-select">
        <option value="">Filter by fork...</option>
        <option value="PHASE0">Phase 0</option>
        <option value="ALTAIR">Altair</option>
        <option value="BELLATRIX">Bellatrix</option>
        <option value="CAPELLA">Capella</option>
        <option value="DENEB">Deneb</option>
        <option value="ELECTRA">Electra</option>
        <option value="FULU">Fulu</option>
      </select>
      
      <select id="changeFilter" class="filter-select">
        <option value="">Filter by changes...</option>
        <option value="PHASE0">Changed in Phase 0</option>
        <option value="ALTAIR">Changed in Altair</option>
        <option value="BELLATRIX">Changed in Bellatrix</option>
        <option value="CAPELLA">Changed in Capella</option>
        <option value="DENEB">Changed in Deneb</option>
        <option value="ELECTRA">Changed in Electra</option>
        <option value="FULU">Changed in Fulu</option>
      </select>
      
      <select id="typeFilter" class="filter-select">
        <option value="">Filter by type...</option>
        <option value="constant_vars">Constants</option>
        <option value="preset_vars">Preset Variables</option>
        <option value="config_vars">Configuration Variables</option>
        <option value="custom_types">Custom Types</option>
        <option value="dataclasses">Dataclasses</option>
        <option value="ssz_objects">SSZ Objects</option>
        <option value="functions">Functions</option>
      </select>
      
      <button id="applyFilters" class="filter-button">Apply Filters</button>
      <button id="clearFilters" class="filter-button">Clear Filters</button>
    </div>
  </div>
  
  <div id="activeFilters" class="filter-container"></div>
  
  <div id="toggleDiffContainer" class="toggle-container hidden">
    <label>
      Show diff between upgrades
      <input type="checkbox" id="showDiffToggle" class="show-diff-checkbox">
    </label>
  </div>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Constants
    </summary>
    <div id="constant_vars"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Preset Variables
    </summary>
    <div id="preset_vars"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Configuration Variables
    </summary>
    <div id="config_vars"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Custom Types
    </summary>
    <div id="custom_types"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Dataclasses
    </summary>
    <div id="dataclasses"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      SSZ Objects
    </summary>
    <div id="ssz_objects"></div>
  </details>

  <details>
    <summary>
      <span class="summary-icon"></span>
      Functions
    </summary>
    <div id="functions"></div>
  </details>

  <div id="noResults" class="no-results hidden">No results found for your search criteria.</div>

  <script>
    let jsonData = {};
    let deprecatedItems = new Set();
    
    // Map to store all items by their ID (for direct linking)
    let itemsById = new Map();
    
    // Currently active filters
    let activeFilters = {
      search: '',
      fork: '',
      change: '',
      type: '',
      deprecated: false
    };

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Shared Helper Functions
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function getForkColor(forkName) {
      const colors = {
        PHASE0:    "#6c757d", // gray
        ALTAIR:    "#28a745", // green
        BELLATRIX: "#007bff", // blue
        CAPELLA:   "#6f42c1", // purple
        DENEB:     "#e83e8c", // pink
        ELECTRA:   "#ffc107", // yellow
        FULU:      "#c1c107", // greenish yellow
      };
      const up = forkName.toUpperCase();
      return colors[up] || "#17a2b8"; // fallback = teal
    }

    function phaseIncluded(phaseName) {
      return !phaseName.toUpperCase().startsWith("EIP")
        && phaseName.toUpperCase() != "WHISK";
    }

    function getIncludedForks(presetData) {
      if (!presetData) return [];
      return Object.keys(presetData).filter(phaseIncluded);
    }

    function parseForkName(varName, knownForkNames) {
      const varNameUpper = varName.toUpperCase();
      for (const forkNameUpper of knownForkNames) {
        const suffix = "_" + forkNameUpper;
        if (varNameUpper.endsWith(suffix)) {
          const base = varName.slice(0, varName.length - suffix.length);
          return { base, fork: forkNameUpper };
        }
      }
      return { base: varName, fork: null };
    }

    function parseValue(fields) {
      return {
        type: fields[0] ?? "Unknown",
        value: fields[1] ?? "N/A",
      };
    }

    function forkGroupCompareAscending(a, b) {
      if (a === "PHASE0" && b !== "PHASE0") return -1;
      if (b === "PHASE0" && a !== "PHASE0") return 1;
      return a.localeCompare(b);
    }

    function forkGroupCompareDescending(a, b) {
      if (a === "PHASE0" && b !== "PHASE0") return 1;
      if (b === "PHASE0" && a !== "PHASE0") return -1;
      return b.localeCompare(a);
    }

    // Generate a unique ID for an item
    function generateItemId(category, name) {
      // Convert to URL-friendly format
      const urlName = name.replace(/[^\w-]+/g, '_');
      return `${category}-${urlName}`;
    }

    // Create share link for an item
    function createShareLink(itemId) {
      const url = new URL(window.location.href);
      url.hash = itemId;
      return url.href;
    }

    // Check if an item is deprecated
    function isItemDeprecated(itemName) {

      return deprecatedItems.has(itemName);
    }

    // Highlight diffs between two pieces of text
    function highlightDiff(oldText, newText) {
      if (!oldText || !newText) return newText;

      const oldLines = oldText.split('\n');
      const newLines = newText.split('\n');
      
      // Highlight entire lines that are different
      const result = [];
      const maxLines = Math.max(oldLines.length, newLines.length);
      
      for (let i = 0; i < maxLines; i++) {
        if (i >= newLines.length) {
          // Line was removed
          result.push(`<div class="diff-highlight-removed">${oldLines[i]}</div>`);
        } else if (i >= oldLines.length) {
          // Line was added
          result.push(`<div class="diff-highlight-added">${newLines[i]}</div>`);
        } else if (oldLines[i] !== newLines[i]) {
          // Line was changed
          result.push(`<div class="diff-highlight-removed">${oldLines[i]}</div>`);
          result.push(`<div class="diff-highlight-added">${newLines[i]}</div>`);
        } else {
          // Line is the same
          result.push(newLines[i]);
        }
      }
      
      return result.join('\n');
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Variables (Constants, Presets, Configurations)
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function getForkValue(fk, baseVal, forkArr) {
      if (!baseVal) return { value: undefined, type: "" };
      if (fk === baseVal.introducingFork) {
        return { value: baseVal.value, type: baseVal.type };
      }
      if (!forkArr) return { value: undefined, type: "" };

      let foundVal = null;
      let foundType = null;
      forkArr.forEach((f) => {
        if (f.fork === fk) {
          foundVal = f.value;
          foundType = f.type;
        }
      });
      if (foundVal === null) {
        return { value: undefined, type: "" };
      }
      return { value: foundVal, type: foundType };
    }

    function buildRows(mBase, mForks, nBase, nForks) {
      const allForks = new Set();
      if (mBase) allForks.add(mBase.introducingFork);
      (mForks || []).forEach((f) => allForks.add(f.fork));

      if (nBase) allForks.add(nBase.introducingFork);
      (nForks || []).forEach((f) => allForks.add(f.fork));

      let forkArray = Array.from(allForks);
      forkArray.sort(forkGroupCompareDescending);

      return forkArray.map((fk) => {
        const mainnet = getForkValue(fk, mBase, mForks);
        const minimal = getForkValue(fk, nBase, nForks);

        return {
          fork: fk,
          type: mainnet.type,
          mainnetValue: mainnet.value,
          minimalValue: minimal.value,
        };
      });
    }

    function buildTable(rows, showDiff = false) {
      if (!rows.length) {
        return `<p style="color: grey;">No data</p>`;
      }
      
      // Create rows with diff highlighting if requested
      const rowHTML = rows.map((r, index) => {
        let mainnetValue = r.mainnetValue;
        let minimalValue = r.minimalValue;
        
        // If showing diffs and we have a previous row to compare with
        if (showDiff && index < rows.length - 1) {
          const prevRow = rows[index + 1]; // Since rows are sorted in descending order
          mainnetValue = highlightDiff(prevRow.mainnetValue, mainnetValue);
          minimalValue = highlightDiff(prevRow.minimalValue, minimalValue);
        }
        
        return `
          <tr>
            <td>${r.fork}</td>
            <td>${r.type}</td>
            <td>${mainnetValue}</td>
            <td>${minimalValue}</td>
          </tr>
        `;
      }).join("");

      return `
        <table class="fork-table">
          <thead>
            <tr>
              <th>Fork</th>
              <th>Type</th>
              <th>Mainnet</th>
              <th>Minimal</th>
            </tr>
          </thead>
          <tbody>${rowHTML}</tbody>
        </table>
      `;
    }

    function buildVariableSummary(name, mBase, mForks, displayTypeAndValue = true) {
      if (!mBase && (!mForks || !mForks.length)) {
        return `${name} = (no mainnet data)`;
      }

      const forkNames = new Set();
      if (mBase) forkNames.add(mBase.introducingFork);
      if (mForks) {
        mForks.forEach((f) => forkNames.add(f.fork));
      }

      const sortedForks = Array.from(forkNames).sort(forkGroupCompareDescending);

      const badges = sortedForks
        .map((fork) => {
          const color = getForkColor(fork);
          return `<span class="badge" style="background-color: ${color}">${fork}</span>`;
        })
        .join(" ");

      let lastVal = mBase?.value || "N/A";
      let lastType = mBase?.type || "";

      if (mForks && mForks.length > 0) {
        const newest = mForks[mForks.length - 1];
        lastVal = newest.value;
        lastType = newest.type || lastType;
      }

      /* If there's a large value (eg KZG_SETUP) don't show the value */
      if (String(lastVal).length > 64) {
        displayTypeAndValue = false;
      }
      
      // Add deprecated badge if needed
      const deprecatedBadge = isItemDeprecated(name) ? 
        '<span class="deprecated-badge">DEPRECATED</span>' : '';

      if (displayTypeAndValue) {
        const displayType = lastType && lastType !== "Unknown" ? `: ${lastType} = ` : ` = `;
        return `${name}${displayType}${lastVal} ${badges} ${deprecatedBadge}`;
      } else {
        return `${name} ${badges} ${deprecatedBadge}`;
      }
    }

    function renderVariable(baseName, mBase, mForks, nBase, nForks, category) {
      const rows = buildRows(mBase, mForks, nBase, nForks);
      const showDiff = document.getElementById('showDiffToggle')?.checked || false;
      const table = buildTable(rows, showDiff);
      const summaryText = buildVariableSummary(baseName, mBase, mForks);
      
      // Generate a unique ID for this item
      const itemId = generateItemId(category, baseName);
      
      const details = document.createElement("details");
      details.className = "preset-group";
      details.id = itemId;
      
      // Add deprecated class if needed
      if (isItemDeprecated(baseName)) {
        details.classList.add("deprecated-item");
      }
      
      // Save reference to this item for direct linking
      itemsById.set(itemId, details);

      const summary = document.createElement("summary");
      const shareLink = createShareLink(itemId);
      
      summary.innerHTML = `
        <span class="summary-icon"></span>
        <span class="collapsed-header">${summaryText}</span>
        <button class="share-button" data-link="${shareLink}" title="Copy link to this item">
          <i class="fas fa-link"></i>
        </button>
      `;
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "expanded-content";
      content.innerHTML = table;
      details.appendChild(content);
      
      // Add data attributes for filtering
      details.dataset.name = baseName.toLowerCase();
      details.dataset.category = category;
      
      // Add fork data for filtering
      if (mBase) {
        details.dataset.introducingFork = mBase.introducingFork;
      }
      
      const forkSet = new Set();
      if (mBase) forkSet.add(mBase.introducingFork);
      if (mForks) {
        mForks.forEach(f => forkSet.add(f.fork));
      }
      details.dataset.forks = Array.from(forkSet).join(' ');
      
      // Add changes data for filtering
      if (mForks && mForks.length > 0) {
        details.dataset.changedInForks = mForks.map(f => f.fork).join(' ');
      }
      
      // Add deprecated data for filtering
      if (isItemDeprecated(baseName)) {
        details.dataset.deprecated = "true";
      }

      return details;
    }

    function collectVariables(data, field) {
      const baseVars = {};
      const forkVars = {};
      const lastForkValue = {};

      if (!data) return { baseVars, forkVars };

      const includedPhases = getIncludedForks(data);
      const knownForkNames = includedPhases.map((p) => p.toUpperCase());

      includedPhases.forEach((phaseName) => {
        const phaseObj = data[phaseName];
        if (!phaseObj?.[field]) return;

        Object.keys(phaseObj[field]).forEach((varName) => {
          const { base, fork } = parseForkName(varName, knownForkNames);
          const parsed = parseValue(phaseObj[field][varName]);

          if (!baseVars[base]) {
            baseVars[base] = {
              type: parsed.type,
              value: parsed.value,
              introducingFork: (fork || phaseName).toUpperCase(),
            };
          }

          if (!fork) {
            baseVars[base].type = parsed.type;
            baseVars[base].value = parsed.value;
            return;
          }

          if (!forkVars[base]) {
            forkVars[base] = [];
          }
          if (!lastForkValue[base]) {
            lastForkValue[base] = {};
          }
          if (lastForkValue[base][fork] === undefined) {
            lastForkValue[base][fork] = baseVars[base].value;
          }
          const prevVal = lastForkValue[base][fork];
          if (parsed.value !== prevVal) {
            forkVars[base].push({fork, value: parsed.value, type: parsed.type});
            lastForkValue[base][fork] = parsed.value;
          }
        });
      });

      return { baseVars, forkVars };
    }

    function addVariables(jsonData, fieldName) {
        const mainnetPresets = collectVariables(jsonData.mainnet, fieldName);
        const minimalPresets = collectVariables(jsonData.minimal, fieldName);

        const allPresetVars = new Set([
          ...Object.keys(mainnetPresets.baseVars),
          ...Object.keys(minimalPresets.baseVars),
        ]);

        const presetGroups = {};
        allPresetVars.forEach((baseName) => {
          const mVal = mainnetPresets.baseVars[baseName];
          const nVal = minimalPresets.baseVars[baseName];
          const grp = mVal?.introducingFork || nVal?.introducingFork;
          if (!presetGroups[grp]) presetGroups[grp] = [];
          presetGroups[grp].push(baseName);
        });

        const presetGroupKeys = Object.keys(presetGroups).sort(forkGroupCompareAscending);

        const presetVarsContainer = document.getElementById(fieldName);
        presetVarsContainer.innerHTML = "";

        presetGroupKeys.forEach((groupName) => {
          const groupDiv = document.createElement("div");
          groupDiv.className = "phase-group";
          groupDiv.innerHTML = `<h2>${groupName}</h2>`;

          const varNames = presetGroups[groupName];
          varNames.sort();
          varNames.forEach((vName) => {
            const row = renderVariable(
              vName,
              mainnetPresets.baseVars[vName],
              mainnetPresets.forkVars[vName] || [],
              minimalPresets.baseVars[vName],
              minimalPresets.forkVars[vName] || [],
              fieldName
            );
            groupDiv.appendChild(row);
          });

          presetVarsContainer.appendChild(groupDiv);
        });
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Items (Functions, SSZ Objects, Dataclasses, Custom Types)
    ///////////////////////////////////////////////////////////////////////////////////////////////

    function buildItemSummary(name, mForks, displayValueInSummary) {
      const forkNames = new Set();
      mForks.forEach((f) => forkNames.add(f.fork));
      const sortedForks = Array.from(forkNames).sort(forkGroupCompareDescending);

      const badges = sortedForks
        .map((fork) => {
          const color = getForkColor(fork);
          return `<span class="badge" style="background-color: ${color}">${fork}</span>`;
        })
        .join(" ");

      let lastVal = mForks[0].value || "N/A";
      if (mForks && mForks.length > 0) {
        const newest = mForks[mForks.length - 1];
        lastVal = newest.value;
      }
      
      // Add deprecated badge if needed
      const deprecatedBadge = isItemDeprecated(name) ? 
        '<span class="deprecated-badge">DEPRECATED</span>' : '';

      if (displayValueInSummary) {
        return `${name} = ${lastVal} ${badges} ${deprecatedBadge}`;
      } else {
        return `${name} ${badges} ${deprecatedBadge}`;
      }
    }

    function renderItem(baseName, mForks, displayValueInSummary, category) {
      const summaryText = buildItemSummary(baseName, mForks, displayValueInSummary);
      
      // Generate a unique ID for this item
      const itemId = generateItemId(category, baseName);

      const details = document.createElement("details");
      details.className = "preset-group";
      details.id = itemId;
      
      // Add deprecated class if needed
      if (isItemDeprecated(baseName)) {
        details.classList.add("deprecated-item");
      }
      
      // Save reference to this item for direct linking
      itemsById.set(itemId, details);

      const summary = document.createElement("summary");
      const shareLink = createShareLink(itemId);
      
      summary.innerHTML = `
        <span class="summary-icon"></span>
        <span class="collapsed-header">${summaryText}</span>
        <button class="share-button" data-link="${shareLink}" title="Copy link to this item">
          <i class="fas fa-link"></i>
        </button>
      `;
      details.appendChild(summary);

      const content = document.createElement("div");
      content.className = "expanded-content";
      
      // Add show diff toggle
      const showDiff = document.getElementById('showDiffToggle')?.checked || false;

      // Store fork details in a more accessible way for filtering
      let forkDetails = [];
      
      // Initially, the first fork is open, others are closed
      var openOrNot = "open";
      
      // Add each fork's code block
      for (const {fork, value} of [...mForks].reverse()) {
        const section = document.createElement('div');
        
        // If showing diffs and this isn't the last fork value, compare with next value
        let displayValue = value;
        if (showDiff && mForks.length > 1) {
          // Find the next newer fork if any
          const forkIndex = mForks.findIndex(f => f.fork === fork);
          if (forkIndex > 0) {
            const olderFork = mForks[forkIndex - 1];
            displayValue = highlightDiff(olderFork.value, value);
          }
        }
        
        // Explicitly create the fork details element to track it
        const forkDetailHTML = `
          <details ${openOrNot} class="preset-group fork-code-block" data-fork="${fork}">
            <summary>
              <span class="summary-icon"></span>
              <span class="badge" style="background-color: ${getForkColor(fork)}">${fork}</span>
            </summary>
            <pre class="line-numbers"><code class="language-python">${displayValue}</code></pre>
          </details>
        `;
        
        section.innerHTML = forkDetailHTML;
        content.appendChild(section);
        
        // Keep track of this fork detail for filtering
        forkDetails.push(fork);
        
        // Only the first one is open by default
        openOrNot = "";
      }

      details.appendChild(content);
      
      // Add data attributes for filtering
      details.dataset.name = baseName.toLowerCase();
      details.dataset.category = category;
      
      // Add fork data for filtering
      if (mForks && mForks.length > 0) {
        details.dataset.introducingFork = mForks[0].fork;
        details.dataset.forks = mForks.map(f => f.fork).join(' ');
        // Store available fork blocks
        details.dataset.forkBlocks = JSON.stringify(forkDetails);
      }
      
      // Add changes data for filtering
      if (mForks && mForks.length > 1) {
        details.dataset.changedInForks = mForks.slice(1).map(f => f.fork).join(' ');
      }
      
      // Add deprecated data for filtering
      if (isItemDeprecated(baseName)) {
        details.dataset.deprecated = "true";
      }

      return details;
    }

    function collectItems(data, field) {
      const items = {};
      const lastForkValue = {};

      getIncludedForks(data).forEach((forkName) => {
        const forkObj = data[forkName];
        if (!forkObj?.[field]) return;

        Object.keys(forkObj[field]).forEach((itemName) => {
          const value = forkObj[field][itemName];
          const fork = forkName.toUpperCase();

          if (!items[itemName]) {
            items[itemName] = [{ fork, value: value}];
            lastForkValue[itemName] = value;
            return;
          }

          if (value !== lastForkValue[itemName]) {
            items[itemName].push({fork, value: value});
            lastForkValue[itemName] = value;
          }
        });
      });

      return items;
    }

    function addItems(jsonData, fieldName, displayValueInSummary = false) {
        const items = collectItems(jsonData.mainnet, fieldName);

        const itemGroups = {};
        Object.keys(items).forEach((itemName) => {
          const value = items[itemName];
          const group = value[0].fork;
          if (!itemGroups[group]) itemGroups[group] = [];
          itemGroups[group].push(itemName);
        });

        const itemContainer = document.getElementById(fieldName);
        itemContainer.innerHTML = "";
        
        Object.keys(itemGroups).sort(forkGroupCompareAscending).forEach((groupName) => {
          const groupDiv = document.createElement("div");
          groupDiv.className = "phase-group";
          groupDiv.innerHTML = `<h2>${groupName}</h2>`;
          itemGroups[groupName].sort().forEach((itemName) => {
            groupDiv.appendChild(renderItem(itemName, items[itemName], displayValueInSummary, fieldName));
          });
          itemContainer.appendChild(groupDiv);
        });
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Search and Filtering
    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    function applyFilters() {
      const searchInput = document.getElementById('searchInput').value.toLowerCase();
      const forkFilter = document.getElementById('forkFilter').value;
      const changeFilter = document.getElementById('changeFilter').value;
      const typeFilter = document.getElementById('typeFilter').value;
      
      activeFilters = {
        search: searchInput,
        fork: forkFilter,
        change: changeFilter,
        type: typeFilter,
        deprecated: false
      };
      
      updateActiveFiltersDisplay();
      filterItems();
      
      // Show/hide diff toggle based on whether we're filtering for a single type
      const toggleDiffContainer = document.getElementById('toggleDiffContainer');
      if (typeFilter) {
        toggleDiffContainer.classList.remove('hidden');
      } else {
        toggleDiffContainer.classList.add('hidden');
      }
    }
    
    function clearFilters() {
      document.getElementById('searchInput').value = '';
      document.getElementById('forkFilter').value = '';
      document.getElementById('changeFilter').value = '';
      document.getElementById('typeFilter').value = '';
      document.getElementById('searchClear').classList.add('hidden');
      
      activeFilters = {
        search: '',
        fork: '',
        change: '',
        type: '',
        deprecated: false
      };
      
      updateActiveFiltersDisplay();
      filterItems();
      
      document.getElementById('toggleDiffContainer').classList.add('hidden');
    }
    
    function updateActiveFiltersDisplay() {
      const container = document.getElementById('activeFilters');
      container.innerHTML = '';
      
      let hasFilters = false;
      
      if (activeFilters.search) {
        container.appendChild(createFilterBadge('Search', activeFilters.search));
        hasFilters = true;
      }
      
      if (activeFilters.fork) {
        container.appendChild(createFilterBadge('Fork', activeFilters.fork));
        hasFilters = true;
      }
      
      if (activeFilters.change) {
        container.appendChild(createFilterBadge('Changed in', activeFilters.change));
        hasFilters = true;
      }
      
      if (activeFilters.type) {
        let displayType = activeFilters.type;
        switch(activeFilters.type) {
          case 'constant_vars': displayType = 'Constants'; break;
          case 'preset_vars': displayType = 'Preset Variables'; break;
          case 'config_vars': displayType = 'Configuration Variables'; break;
          case 'custom_types': displayType = 'Custom Types'; break;
          case 'dataclasses': displayType = 'Dataclasses'; break;
          case 'ssz_objects': displayType = 'SSZ Objects'; break;
          case 'functions': displayType = 'Functions'; break;
        }
        container.appendChild(createFilterBadge('Type', displayType));
        hasFilters = true;
      }
      
      if (activeFilters.deprecated) {
        container.appendChild(createFilterBadge('Status', 'Deprecated'));
        hasFilters = true;
      }
    }
    
    function createFilterBadge(label, value) {
      const badge = document.createElement('div');
      badge.className = 'filter-badge';
      badge.innerHTML = `${label}: ${value} <span class="filter-badge-remove">×</span>`;
      
      badge.querySelector('.filter-badge-remove').addEventListener('click', () => {
        // Remove this specific filter
        switch(label) {
          case 'Search': 
            document.getElementById('searchInput').value = '';
            activeFilters.search = ''; 
            document.getElementById('searchClear').classList.add('hidden');
            break;
          case 'Fork': 
            document.getElementById('forkFilter').value = '';
            activeFilters.fork = ''; 
            break;
          case 'Changed in': 
            document.getElementById('changeFilter').value = '';
            activeFilters.change = ''; 
            break;
          case 'Type': 
            document.getElementById('typeFilter').value = '';
            activeFilters.type = ''; 
            document.getElementById('toggleDiffContainer').classList.add('hidden');
            break;
          case 'Status': 
            activeFilters.deprecated = false; 
            break;
        }
        
        updateActiveFiltersDisplay();
        filterItems();
      });
      
      return badge;
    }
    
    function filterItems() {
      // 1. First handle the top-level category sections (Constants, Functions, etc.)
      if (activeFilters.type) {
        // Only open the type filter's section
        document.querySelectorAll('body > details').forEach(section => {
          if (section.querySelector('div').id === activeFilters.type) {
            section.setAttribute('open', 'true');
          } else {
            section.removeAttribute('open');
          }
        });
      } else {
        // Don't change the open/closed state of sections when not filtering by type
      }
      
      // 2. Get all item sections (individual function/constant/etc. items)
      const allSections = document.querySelectorAll('details.preset-group:not(.fork-code-block)');
      const sectionContainers = document.querySelectorAll('details > div');
      let visibleCount = 0;
      
      // 3. Apply filters to each item
      allSections.forEach(section => {
        let isVisible = true;
        
        // Check each filter
        if (activeFilters.search && !section.dataset.name?.toLowerCase().includes(activeFilters.search)) {
          isVisible = false;
        }
        
        if (activeFilters.fork && !section.dataset.forks?.includes(activeFilters.fork)) {
          isVisible = false;
        }
        
        if (activeFilters.change && !section.dataset.changedInForks?.includes(activeFilters.change)) {
          isVisible = false;
        }
        
        if (activeFilters.type && section.dataset.category !== activeFilters.type) {
          isVisible = false;
        }
        
        if (activeFilters.deprecated && section.dataset.deprecated !== "true") {
          isVisible = false;
        }
        
        // Apply visibility
        section.classList.toggle('hidden', !isVisible);
        
        // 4. Only handle fork code blocks for visible items
        if (isVisible) {
          visibleCount++;
          
          // If filtering by fork, we need to prepare nested blocks but not auto-expand the parent
          if (activeFilters.fork) {
            // Get all nested code blocks
            const forkBlocks = section.querySelectorAll('.expanded-content details.fork-code-block');
            let foundMatchingFork = false;
            
            forkBlocks.forEach(block => {
              const fork = block.getAttribute('data-fork');
              
              if (fork === activeFilters.fork) {
                // This fork matches our filter - prepare it to be shown when parent is expanded
                block.classList.remove('hidden');
                block.setAttribute('open', 'true');
                foundMatchingFork = true;
                                
                // Pre-highlight code
                const codeElement = block.querySelector('code');
                if (codeElement) {
                  // Queue for syntax highlighting
                  Prism.highlightElement(codeElement);
                }
              } else {
                // This fork doesn't match - hide it
                block.classList.add('hidden');
              }
            });
            
            // Hide items with no matching fork
            if (forkBlocks.length > 0 && !foundMatchingFork) {
              section.classList.add('hidden');
              visibleCount--;
            }
          } else {
            // Not filtering by fork - ensure all fork blocks are visible
            // But don't auto-expand parent items
            const forkBlocks = section.querySelectorAll('.expanded-content details.fork-code-block');
            forkBlocks.forEach(block => {
              block.classList.remove('hidden');
            });
            
            // Make sure at least first fork block is open by default 
            // (but don't change parent item expansion state)
            if (section.hasAttribute('open')) {
              const firstBlock = forkBlocks[0];
              if (firstBlock) {
                firstBlock.setAttribute('open', 'true');
                forkBlocks.forEach((block, index) => {
                  if (index > 0) block.removeAttribute('open');
                });
              }
            }
          }
        }
      });
      
      // 5. Update phase-group visibility (hide empty groups)
      sectionContainers.forEach(container => {
        // Get the parent phase-groups
        const phaseGroups = container.querySelectorAll('.phase-group');
        
        // For each phase-group, hide if it has no visible children
        phaseGroups.forEach(group => {
          const hasVisibleChildren = group.querySelectorAll('details.preset-group:not(.hidden)').length > 0;
          group.classList.toggle('hidden', !hasVisibleChildren);
        });
      });
      
      // 6. Show message if no results
      document.getElementById('noResults').classList.toggle('hidden', visibleCount > 0);
      
      // 7. Refresh syntax highlighting
      Prism.highlightAll();
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Dark Mode
    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    function initDarkMode() {
      const darkModeToggle = document.getElementById('darkModeToggle');
      
      // Check for saved preference or system preference
      const savedTheme = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      
      // Set initial state
      if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
        document.documentElement.setAttribute('data-theme', 'dark');
        darkModeToggle.checked = true;
      }
      
      // Toggle dark mode
      darkModeToggle.addEventListener('change', function() {
        if (this.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
        } else {
          document.documentElement.removeAttribute('data-theme');
          localStorage.setItem('theme', 'light');
        }
        
        // Refresh syntax highlighting
        if (typeof Prism !== 'undefined') {
          Prism.highlightAll();
        }
      });
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Direct linking to items
    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    function handleDirectLinks() {
      // Check if URL has a hash
      if (window.location.hash) {
        const itemId = window.location.hash.substring(1);
        
        // After the data is loaded and rendered
        setTimeout(() => {
          const item = document.getElementById(itemId);
          if (item) {
            // Open all parent details elements
            let parent = item.parentElement;
            while (parent) {
              if (parent.tagName === 'DETAILS') {
                parent.setAttribute('open', 'true');
              }
              parent = parent.parentElement;
            }
            
            // Open the item itself
            item.setAttribute('open', 'true');
            
            // Scroll to the item (with a slight delay to let rendering complete)
            setTimeout(() => {
              item.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 100);
          }
        }, 500);
      }
    }
    
    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Event Listeners
    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    function initEventListeners() {
      // Search input event
      const searchInput = document.getElementById('searchInput');
      const searchClear = document.getElementById('searchClear');
      
      searchInput.addEventListener('input', function() {
        const hasText = this.value.length > 0;
        searchClear.classList.toggle('hidden', !hasText);
        applyFilters();
      });
      
      searchClear.addEventListener('click', function() {
        searchInput.value = '';
        this.classList.add('hidden');
        applyFilters();
      });
      
      // Filter buttons
      document.getElementById('applyFilters').addEventListener('click', applyFilters);
      document.getElementById('clearFilters').addEventListener('click', clearFilters);
      
      // Diff toggle
      document.getElementById('showDiffToggle').addEventListener('change', function() {
        loadData(); // Reload and re-render to apply diff highlighting
      });
      
      // Share button click event (delegation)
      document.addEventListener('click', function(e) {
        if (e.target.closest('.share-button')) {
          const shareButton = e.target.closest('.share-button');
          const link = shareButton.dataset.link;
          
          // Copy link to clipboard
          navigator.clipboard.writeText(link).then(() => {
            // Show a brief visual confirmation
            shareButton.innerHTML = '<i class="fas fa-check"></i>';
            setTimeout(() => {
              shareButton.innerHTML = '<i class="fas fa-link"></i>';
            }, 1000);
          });
        }
      });
    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Deprecated Items
    ///////////////////////////////////////////////////////////////////////////////////////////////
    
    function initDeprecatedItems() {

    }

    ///////////////////////////////////////////////////////////////////////////////////////////////
    // Render Everything
    ///////////////////////////////////////////////////////////////////////////////////////////////

    async function loadData() {
      try {
        const resp = await fetch("pyspec.json");
        if (!resp.ok) throw new Error(`HTTP error: ${resp.status}`);
        jsonData = await resp.json();

        addVariables(jsonData, "constant_vars");
        addVariables(jsonData, "preset_vars");
        addVariables(jsonData, "config_vars");
        addItems(jsonData, "custom_types", displayValueInSummary=true);
        addItems(jsonData, "dataclasses");
        addItems(jsonData, "ssz_objects");
        addItems(jsonData, "functions");
        
        // Apply any active filters
        filterItems();
        
        // Handle direct links
        handleDirectLinks();

      } catch (err) {
        console.error("Error loading data:", err);
        // Display error message to user
        document.getElementById('noResults').innerHTML = `
          <p>Error loading specification data: ${err.message}</p>
          <p>Make sure pyspec.json is available in the same directory as this HTML file.</p>
        `;
        document.getElementById('noResults').classList.remove('hidden');
      }

      Prism.highlightAll();
    }

    // Fallback data function to show example data if JSON loading fails
    function loadFallbackData() {
      console.log("Loading fallback data");
      
      // Example data structure that matches expected format
      const fallbackData = {
        mainnet: {
          PHASE0: {
            constant_vars: {
              "EXAMPLE_CONSTANT": ["uint64", "1234"],
              "ANOTHER_CONSTANT": ["string", "example value"]
            },
            preset_vars: {
              "EXAMPLE_PRESET": ["uint64", "5678"]
            },
            config_vars: {
              "EXAMPLE_CONFIG": ["string", "test"]
            },
            custom_types: {
              "ExampleType": "type ExampleType = uint64"
            },
            dataclasses: {
              "ExampleClass": "class ExampleClass(Container):\n    field1: uint64\n    field2: boolean"
            },
            ssz_objects: {
              "ExampleSSZ": "class ExampleSSZ(Container):\n    field1: uint64\n    field2: Bytes32"
            },
            functions: {
              "example_function": "def example_function(x: uint64) -> uint64:\n    return x * 2"
            }
          }
        },
        minimal: {
          PHASE0: {
            constant_vars: {
              "EXAMPLE_CONSTANT": ["uint64", "1234"],
            },
            preset_vars: {
              "EXAMPLE_PRESET": ["uint64", "1234"]
            }
          }
        }
      };
      
      // If fetch fails to load data after 3 seconds, use fallback data
      setTimeout(() => {
        if (Object.keys(jsonData).length === 0) {
          console.log("Using fallback data");
          jsonData = fallbackData;
          
          addVariables(jsonData, "constant_vars");
          addVariables(jsonData, "preset_vars");
          addVariables(jsonData, "config_vars");
          addItems(jsonData, "custom_types", displayValueInSummary=true);
          addItems(jsonData, "dataclasses");
          addItems(jsonData, "ssz_objects");
          addItems(jsonData, "functions");
          
          // Apply any active filters
          filterItems();
          
          // Add notice about fallback data
          const notice = document.createElement('div');
          notice.style.background = '#ffe6cc';
          notice.style.color = '#663c00';
          notice.style.padding = '10px';
          notice.style.marginBottom = '20px';
          notice.style.borderRadius = '4px';
          notice.innerHTML = '<strong>Note:</strong> Displaying example data. Could not load pyspec.json.';
          document.body.insertBefore(notice, document.body.firstChild);
          
          Prism.highlightAll();
        }
      }, 3000);
    }

    // Initialize
    initDarkMode();
    initEventListeners();
    initDeprecatedItems();
    loadData();
    loadFallbackData(); // Add fallback data if the main load fails
  </script>
